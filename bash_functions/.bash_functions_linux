# .bash_functions
# list of bash functions


# add to PATH variable
pathadd() {
	if [[ $# -eq 0 ]] ; then
		echo "pathadd: err: incorrect number of arguments"
		return 1
	fi

	NEW=${1%/}
	if [[ -d "$1" ]] && ! echo $PATH | grep -E -q "(^|:)$NEW($|:)" ; then
		if [ "$2" == "after" ] ; then
			export PATH="$PATH:$NEW"
		else
			export PATH="$NEW:$PATH"
		fi
	fi
}

# remove from PATH variable
pathrm() {
	export PATH=`echo $PATH | sed -e "s;\(^\|:\)${1%/}\(:\|\$\);\1\2;g" -e 's;^:\|:$;;g' -e 's;::;:;g'`
}

# remove duplicates from PATH variable (deduplicate)
pathdedup() {
	export PATH=`perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, $ENV{PATH}))'`
}

# get the default branch for a git repo
gitdefault() {
	git remote show ${1:-"origin"} | grep "HEAD branch" | cut -d ":" -f 2
}

# remove all subdirectories from a directory
rmd() {
	if [ $# -eq 0 ] ; then
		rm -rf -- */
	elif [ $# -eq 1 ] ; then
		rm -rf -- $1/*/
	else
		echo "rmd: err: incorrect number of arguments"
		return 1
	fi
}

# generate a random string of specified length, great for passwords
random() {
	strings /dev/urandom | grep -o '[[:alnum:]]' | head -n ${1:-30} | tr -d '\n'; echo
}

# make a shell script out of the last x commands
makes() {
	fc -rnl > /dev/null 2>&1
	if [[ $? -ne 0 ]] ; then 
		echo "makes: err: history is empty"
		return 1
	fi

	if [ $# -eq 0 ] ; then
		num=1
		name="script.sh"
	elif [ $# -eq 1 ] ; then
		num=$1
		name="script.sh"
	elif [ $# -eq 2 ] ; then
		num=$1
		name=$2
	else
		echo "makes: err: incorrect number of arguments"
		return 1
	fi

	rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
	fc -rnl | head -$num > $rando
	tac $rando > $name
	rm -rf $rando
}

# make a BASH function out of the last x commands
makef() {
	fc -rnl > /dev/null 2>&1
	if [[ $? -ne 0 ]] ; then 
		echo "makef: err: history is empty"
		return 1
	fi

	if [ ! ~/.bash_functions ] ; then
		source=~/.bashrc
	else
		source=~/.bash_functions
	fi

	if [ $# -eq 0 ] ; then
		num=1
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
		name="function_$rando"
	elif [ $# -eq 1 ] ; then
		num=$1
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
		name="function_$rando"
	elif [ $# -eq 2 ] ; then
		num=$1
		name=$2
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
	else
		echo "makef: err: incorrect number of arguments"
		return 1
	fi

	num="$(($num + 1))"

	printf "\n" >> $source
	printf "$name() {\n" >> $source
	fc -rnl | head -$num > $rando
	tac $rando > .tempfile

	index=0
	while IFS='' read -r CMD || [[ -n "$CMD" ]] ; do
		if [ $index -eq 0 ] ; then
			index+=1
			continue
		fi
		printf "$CMD\n" >> $source
	done < ".tempfile"

	printf "}\n" >> $source

	rm -rf .tempfile
	rm -rf $rando
	source ~/.bashrc
}

# remove a BASH Function by name
removef() {
	if [ $# -ne 1 ] ; then
		echo "removef: err: incorrect number of arguments"
	else
		if [ ~/.bash_functions ] ; then
			source=~/.bash_functions
		else
			source=~/.bashrc
		fi

		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n $num | tr -d '\n'; echo)"
		title="$1() {"
		edit=0
		found=0
		count=0
		while IFS='' read -r line || [[ -n "$line" ]] ; do
			if [ "$title" == "$line" ] && [ $edit -eq 0 ] ; then
				edit=1
				found=1
			elif [ "$line" == "}" ] && [ $edit -eq 1 ] ; then
				edit=0
				count="$(($count + 1))"
			else
				if [ $edit -eq 0 ] ; then
					printf "%s\n" "$line" >> $rando
				fi
			fi
		done < "$source"

		cat $rando > $source
		rm -rf $rando
		if [ $found -eq 0 ] ; then
			echo "$1 not found in $source"
		else
			if [ $count -eq 1 ] ; then
				echo "Removed $1 from $source"
				source ~/.bashrc
			else
				echo "Removed $1 $count times from $source"
				source ~/.bashrc
			fi
		fi
	fi
}

# list all BASH functions
lsf() {
	if [ ~/.bash_functions ] ; then
		source=~/.bash_functions
	else
		source=~/.bashrc
	fi

	while IFS='' read -r line || [[ -n $line ]] ; do
		let="$(echo $line | fold -w1)"
		chars="$(echo $let | tr -d '\040\011\012\015')"

		if [[ ( "${chars[*]: -1}" == "{" ) && ( "${chars: -2:1}" == ")" && "${chars: -3:1}" == "(" ) ]] ; then
			len=${#chars}
			len="$(($len - 1))"
			echo "${chars:0:$len}"
		fi
	done < "$source"
}

# function that does nothing (great for testing purposes)
dummy() {
	return 0
}

# intercept the `stderr` and `stdout` of a process
intercept() {
	if [[ $# -ne 1 ]] ; then
		echo "intercept: err: incorrect number of arguments"
		return 1
	fi

	strace -ff -e trace=write -e write=1,2 -p $1
}

# show my current public IP address
publicip() {
	echo `dig +short myip.opendns.com @resolver1.opendns.com`
}

# get location for your public IP address
getlocation() {
	myip="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	details="$(lynx -dump "$(publicip)".ip-adress.com | egrep 'City|State Code|Country Code')"
	frmt="IP: $myip\n"
	index=0
	while IFS= read -r line ; do
		if [ $index -eq 0 ] ; then
			city="$(echo $line | cut -d " " -f2-)"
			let index=index+1
		elif [ $index -eq 1 ] ; then
			country="$(echo $line | cut -d " " -f3-)"
			let index=index+1
		else
			state="$(echo $line | cut -d " " -f3-)"
			let index=index+1
		fi
	done <<< "$details"

	location="Location: $city, $state, $country"
	frmt+="$location"
	echo -e $frmt
}

# make it look like you're busy
busy() {
	cat /dev/urandom | hexdump -C | grep "ca fe"
}

# sort by size of current directory
sbs() {
	if [[ $# -ne 0 ]] ; then
		if [[ $# -eq 1 ]] ; then
			if [[ -d $1 ]] ; then
				cd $1
			else
				echo "sbs: err: $1 is not a valid directory"
				return 1
			fi
		fi
	fi

	du -hs * | sort -h
	
	if [[ $# -ne 0 ]] ; then
		cd -
	fi
}

# make directory prefixed with the date
mkdate() {
	local DIR="$(date +%F)-$1"
	mkdir $DIR
}

# make directory prefixed with the date and change into it
mkcddate() {
	local DIR="$(date +%F)-$1"
	mkdir $DIR
	cd $DIR
}

# sound the alarm
siren() {
	printf '\033[5m\033[91m%b\033[0m' '\'{127,105,105,40,127,117,117} && echo
}

# do you really need a description
rickroll() {
	STRING="$(printf '%b' '\'{116,145,166,145,162,040,147,157,156,156,141,040,147,151,166,145,040,171,157,165,040,165,160,056,056,056})"
	yes "$STRING"
}

# reverse input
rev() {
	if [[ $# -eq 0 ]] ; then
		__=""
		_stdin=""

		read -N1 -t1 __ && {
			(( $? <= 128 )) && {
				IFS= read -rd '' _stdin
				_stdin="$__$_stdin"
			}
		}

		VAL=$_stdin
		if [[ "$VAL" == "" ]] ; then
			echo "rev: err: no input found on stdin"
			return 1
		fi
	else
		if [[ $# -ne 1 ]] ; then
			echo "rev: err: incorrect number of arguments"
			return 1
		fi
		VAL=$1
	fi
	echo $VAL | sed $'s/./&\\\n/g' | sed -ne $'x;H;${x;s/\\n//g;p;}'
}

# list all cows
lscows() {
	COWS=`cowsay -l | tail -n +2 | tr ' ' '\n'`
	for COW in $COWS; do cowsay -f $COW $COW; done
}

# random animal speech
randimal() {
	if [[ $# -eq 0 ]] ; then
		fortune | cowsay -f `cowsay -l | tail -n +2 | tr ' ' '\n' | shuf -n 1` | lolcat
	else
		echo "$1" | cowsay -f `cowsay -l | tail -n +2 | tr ' ' '\n' | shuf -n 1` | lolcat
	fi
}

# list what kinds of files are in a directory
what() {
	find ${1:-"."} -type f | perl -ne 'print "." . $1 if m/\.([^.\/]+)$/'
}

# show percentage of each filetype in directory and its subdirectories
per() {
	stats="$(find ${1:-"."} -type f | sed 's/.*\.//' | sort | uniq -c)"

	total=0
	index=0
	for stat in $stats; do
		if (( $index % 2 == 0 )) ; then
			total="$(($total + $stat))"
		fi
		index="$(($index + 1))"
	done

	index=0
	num=0
	word=0
	out=""
	for stat in $stats; do
		if [[ $index -eq 0 ]] ; then
			num="$stat"
			word=$stat
		else
			word="$word $stat"
		fi
		index="$(($index + 1))"
		if (( $index % 2 == 0 )) ; then
			per="$(echo "scale=10; $num/$total" | bc)"
			per="$(echo "scale=10; $per * 100" | bc)"
			per="$(echo "scale=2; $per/1" | bc)"
			out="$out\n$word ($per%)"
			index=0
			word=""
		fi
	done

	echo -e $out | column -t
}

# list all files of specific type
show() {
	if [[ $# -eq 0 ]] ; then
		echo "show: err: incorrect number of arguments"
		return 1
	elif [[ $# -eq 1 ]] ; then
		find . -type f -name "*.$1"
	else
		while [[ $# -ne 0 ]] ; do
			printf "\033[94m.$1 files:\033[0m\n"
			find . -type f -name "*.$1"
			shift
		done
	fi
}

# get disk usage in a nicer format
dup() {
	if [[ $# -ne 0 ]] ; then
		if [[ -d "$1" ]] ; then
			cd "$1"
		else
			echo "dup: err: $1 is not a valid directory"
			return 1
		fi
	fi

	du -sh --apparent-size *
	DU="$(du -sh --apparent-size .)"
	read -ra ARR <<<"$DU"
	echo " TOTAL: ${ARR[0]}"

	if [[ $# -ne 0 ]] ; then
		cd - > /dev/null
	fi
}

# get disk usage for specific filetype
duf() {
	if [ $# -eq 0 ] ; then
		echo "duf: err: incorrect number of arguments"
		return 1
	fi

	for arg in "$@"; do
		size="$(find . -name "*.$1" -print0 | xargs -0 du --apparent-size -ch | tail -n1)"
		read -ra ARR <<<"$SIZE"
		echo "$1: ${ARR[0] - $1}"
		shift
	done
}

# clear a file
clear() {
	if [[ $# -eq 0 ]] ; then
		command clear
	else
		for file in "$@"; do
			if [[ -f "$file" ]] ; then
				> "$file"
			fi
		done
	fi
}

# select files at random from a directory
get() {
	ls -p | grep -v / | sort -R | tail -${1:-1} | while read FILE ; do
		echo "$FILE"
	done
}

# remove files at random
del() {
	ls -p | grep -v / | sort -R | tail -${1:-1} | while read FILE ; do
		rm -rf "$FILE"
	done
}

# grep line by line
lbl() {
	if [[ $# -ne 2 ]] ; then
		echo "lbl: err: incorrect number of arguments"
		return 1
	fi

	while IFS= read -r RESULT ; do
		echo $RESULT
		read </dev/tty
	done < <(grep "$1" $2)
}

# reset Macbook Pro touch bar
resetbar() {
	pkill "Touch Bar agent"
	killall "ControlStrip"
}

# make a new git repo
mkgit() {
	if [[ $# -ne 1 ]] ; then
		echo "mkgit: err: incorrect number of arguments"
		return 1
	fi

	mkdir "$1"
	cd "$1"
	git init
}

# git clone and cd into new directory
clonecd() {
	git clone "$1" && cd "$(basename "$1")"
}

# create new remote repository on GitHub and push the current commit to it
rcreate() {
	if [[ $# -eq 1 ]] ; then
		REPO="$1"
	else
		REPO="${PWD##*/}"
	fi

	GITHUBUSER=`git config github.user`

	curl -u ${USER:-${GITHUBUSER}} https://api.github.com/user/repos -d "{\"name\": \"${REPONAME:-${REPO}}\", \"private\": false, \"has_issues\": true, \"has_downloads\": true, \"has_wiki\": false}" > /dev/null
	git remote add origin git@github.com:${USER:-${GITHUBUSER}}/${REPONAME:-${REPO}}.git
	git push --set-upstream origin master
}

# execute a file and open it in Sublime
eao() {
	if [[ $# -eq 0 ]] ; then
		echo "eao: err: incorrect number of arguments"
		return 1
	fi

	FILE="$1"
	EXT="${FILE##*.}"
	subl "$1"
	case "$EXT" in
		"sh")	./"$@"			;;
		"py")	python3 "$@"	;;
		"rb")	ruby "$@"		;;
		"java")	java "$@"		;;
		*)		echo "Can't execute $1"
	esac
}

# update Konphig settings for system
update() {
	OS=`ostype`
	if [[ "$OS" == "Mac" ]] ; then
		CMD="MD5 -q"
	else
		CMD="md5sum"
	fi

	VAL=0

	if ! [[ "$($CMD ~/Konphig/.bash_aliases)" == "$($CMD ~/.bash_aliases)" ]] ; then
		echo "Updating .bash_aliases"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_aliases ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_variables)" == "$($CMD ~/.bash_variables)" ]] ; then
		echo "Updating .bash_variables"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_variables ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_functions)" == "$($CMD ~/.bash_functions)" ]] ; then
		echo "Updating .bash_functions"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_functions ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_profile)" == "$($CMD ~/.bash_profile)" ]] ; then
		echo "Updating .bash_profile"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_profile ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bashrc)" == "$($CMD ~/.bashrc)" ]] ; then
		echo "Updating .bashrc"
		VAL=1
		yes | cp -rf ~/Konphig/.bashrc ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.git-prompt.sh)" == "$($CMD ~/.git-prompt.sh)" ]] ; then
		echo "Updating .git-prompt.sh"
		VAL=1
		yes | cp -rf ~/Konphig/.git-prompt.sh ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.gitconfig)" == "$($CMD ~/.gitconfig)" ]] ; then
		echo "Updating .gitconfig"
		VAL=1
		yes | cp -rf ~/Konphig/.gitconfig ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.profile)" == "$($CMD ~/.profile)" ]] ; then
		echo "Updating .profile"
		VAL=1
		yes | cp -rf ~/Konphig/.profile ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.tmux.conf)" == "$($CMD ~/.tmux.conf)" ]] ; then
		echo "Updating .tmux.conf"
		VAL=1
		yes | cp -rf ~/Konphig/.tmux.conf ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.vimrc)" == "$($CMD ~/.vimrc)" ]] ; then
		echo "Updating .vimrc"
		VAL=1
		yes | cp -rf ~/Konphig/.vimrc ~ >/dev/null 2>&1
	fi

	if [[ $VAL -eq 0 ]] ; then
		echo "Nothing to update"
	else
		source ~/.bashrc
	fi
}

# gives the current user execution privileges for a file
gimme() {
	if [[ $# -ne 1 ]] ; then
		echo "gimme: err: incorrect number of arguments"
		return 1
	fi
	chmod +x "$1"
}


