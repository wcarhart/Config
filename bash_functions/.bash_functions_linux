# .bash_functions
# list of bash functions

# extracts compressed and zipped files automatically
extract() {
	if [[ -f $1 ]] ; then
		case $1 in
			*.tar.bz2)		tar xjf $1		;;
			*.tar.gz)		tar xzf $1		;;
			*.bz2)			bunzip2 $1		;;
			*.rar)			unrar x $1		;;
			*.gz)			gunzip $1		;;
			*.tar)			tar xf $1		;;
			*.xz)			tar xJf $1		;;
			*.tbz2)			tar xjf $1		;;
			*.tgz)			tar xzf $1		;;
			*.zip)			unzip $1		;;
			*.Z)			uncompress $1	;;
			*)				echo "'$1' cannot be extracted via extract()" ;;
		esac
	else
		echo "$1 is not a valid file"
		return 1
	fi
}

# changes permissions for a specific file (requires sudo access!)
grab() {
	sudo chown -R ${USER} ${1:-.}
}

# search for a process by name
psgrep() {
	if [[ ! -z $1 ]] ; then
		echo "Grepping for process matching $1..."
		ps aux | grep $1 | grep -v grep
	else
		echo "psgrep: err: need name to grep for"
		return 1
	fi
}

# fix lines
fixlines() {
	/usr/bin/perl -pi~ -e 's/\r\n?/\n/g' "$@" ;
}

# add an alias on the fly
adda() {
	if [[ $# -ne 2 ]] ; then
		echo "adda: err: incorrect number of arguments"
		return 1
	fi

	if [[ ! -f ~/.bash_aliases ]] ; then
		F=~/.bashrc
	else
		F=~/.bash_aliases
	fi

	echo "alias $1='$2'" >> $F
	source ~/.bashrc
}

# add a variable on the fly
addv() {
	if [[ $# -ne 2 ]] ; then
		echo "addv: err: incorrect number of arguments"
		return 1
	fi

	if [[ ! -f ~/.bash_variables ]] ; then
		F=~/.bashrc
	else
		F=~/.bash_variables
	fi

	echo "export $1=$2" >> $F
	source ~/.bashrc
}

# add test files to directory
ranf() {
	touch test.txt
	for i in {0..50} ; do echo "test test test test" >> test.txt ; done
	for ((i=1; i<=${1:-100}; i++)) ; do cat test.txt > test$i.txt ; done
	rm -rf "test.txt"
}

# remove files in directory and its subdirectories
rmr() {
	if [[ $# -eq 0 ]] ; then
		echo "rmr: err: incorrect number of arguments"
		return 1
	fi

	for ARG in "$@" ; do
		find . -name $ARG -delete
	done
}

# move files and change directory
mvcd() {
	if [[ $# -ne 2 ]] ; then
		echo "mvcd: err: incorrect number of arguments"
		return 1
	fi
	
	mv "$@"
	for LAST ; do true ; done
	cd $LAST
}

# move files, change directory, and delete source directory
# WARNING: will forcefully remove source, even if nonempty (use case is with *)
mvrm() {
	if [[ $# -ne 2 ]] ; then
		echo "mvrm: err: incorrect number of arguments"
		return 1
	fi

	mv "$@"
	OLD=$PWD
	for LAS ; do true ; done
	cd $LAST
	rm -rf $OLD
}

# copy files and change directory
cpcd() {
	if [[ $# -ne 2 ]] ; then
		echo "cpcd: err: incorrect number of arguments"
		return 1
	fi

	cp "$@"
	for LAST ; do true ; done
	cd $LAST
}

# copy files with progress bar and change directory
cppcd() {
	if [[ $# -ne 2 ]] ; then
		echo "cppcd: err: incorrect number of arguments"
		return 1
	fi

	rsync --progress "$@"
	for LAST ; do true ; done
	cd $LAST
}

# change directory and list contents
cdls() {
	if [[ $# -ne 1 ]] ; then
		echo "cdls: err: incorrect number of arguments"
		return 1
	fi

	cd "$1"
	ls
}

# make directory and change into it
mkcd() {
	if [[ $# -ne 1 ]] ; then
		echo "mkcd: err: incorrect number of arguments"
		return 1
	fi
		
	mkdir -p "$1" && cd "$1"
}

# make directory and move files into it
mkmv() {
	if [[ $# -ne 2 ]] ; then
		echo "mkmv: err: incorrect number of arguments"
		return 1
	fi

	for DIR ; do true ; done
	mkdir -p "$DIR"
	mv "${*: 1:$#-1}" "$DIR"
}

# make directory, move files into it, then change directory
mkmvcd() {
	if [[ $# -ne 2 ]] ; then
		echo "mkmvcd: err: incorrect number of arguments"
		return 1
	fi

	for DIR ; do true ; done
	mkdir -p "$DIR"
	mv "${*: 1:$#-1}" "$DIR"
	cd "$DIR"
}

# make directory and copy files into it
mkcp() {
	if [[ $# -ne 2 ]] ; then
		echo "mkcp: err: incorrect number of arguments"
		return 1
	fi

	for DIR ; do true ; done
	mkdir -p "$DIR"
	cp "${*: 1:$#-1}" "$DIR"
}

# make directory, copy files into it, then change directory
mkcpcd() {
	if [[ $# -ne 2 ]] ; then
		echo "mkcpcd: err: incorrect number of arguments"
		return 1
	fi

	for DIR ; do true ; done
	mkdir -p "$DIR"
	cp "${*: 1:$#-1}" "$DIR"
	cd "$DIR"
}

# check if the md5sum's of two files match
md5c() {
	if [[ $# -ne 2 ]] ; then
		echo "md5c: err: incorrect number of arguments"
		return 1
	fi

	MD1="$(md5sum $1 | awk '{print $1}')"
	MD2="$(md5sum $2 | awk '{print $1}')"
	if [[ "$MD1" == "$MD2" ]] ; then
		echo "PASS $MD1"
	else
		echo "FAIL $MD1 $MD2"
	fi
}

# count the number of files in a directory and its subdirectories
cf() {
	NUM="$(find ${1:-"."} -type f | wc -l)"
	echo "$NUM files"
}

# change up multiple directories
up() {
	if [[ "$__UPDIR__" == "" ]] || [[ "$__UPDIR__" != *`pwd`* ]] ; then
		export __UPDIR__=`pwd`
	fi
	if [[ -z $1 ]] ; then
		cd ..
	elif [[ $1 -gt 0 ]] ; then
		let COUNT=1
		CDSTR=".."
		while [[ $COUNT -lt $1 ]] ; do
			CDSTR="$CDSTR/.."
			let COUNT=COUNT+1
		done
		cd $CDSTR
	else
		echo "up: err: argument must be a positive integer"
		return 1
	fi
	pwd
}

# go back down one directory if we go up one too many
down() {
	TO="$__UPDIR__"
	if [[ "$TO" == "" ]] ; then
		pwd
		return 0
	fi

	if [[ $# -gt 0 ]] ; then
		[ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null
		if [[ $? -ne 0 ]] ; then
			echo "down: err: argument must be a number"
			return 1
		fi
	fi

	FROM="`pwd`"
	for i in $(seq 1 $1) ; do
		TARGET="${TO##$FROM}"
		if [[ "$TARGET" == "" ]] ; then
			pwd
			return 0
		fi
		
		TARGETARR=(${TARGET//// })
		FROM="`readlink -m $FROM/${TARGETARR[0]}`"
	done

	cd "$FROM"
	pwd
}

# cycle through different prompts (different PS1 variables)
dp() {
	if [[ $# -eq 0 ]] ; then
		# default
		export __PS1__=''
	elif [[ "$1" == "1" ]] ; then
		# minimalist
		export __PS1__="\\$ "
	elif [[ "$1" == "2" ]] ; then
		# just date
		export __PS1__="[\A] > "
	elif [[ "$1" == "3" ]] ; then
		# full date and pwd
		export __PS1__="[\u@\h] \d, \T <\W> \\$ "
	elif [[ "$1" == "4" ]] ; then
		# mood based on last command
		export __PS1__="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]O_O\[\e[0m\]; fi\` \\$ "
	else
		echo "dp: err: invalid prompt index, must be [0,4]"
		return 1
	fi
}

# show most commonly used commands
common() {
	history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head "-n${1:-10}"
}

# kill process by name
kp() {
	if [[ $# -ne 1 ]] ; then
		echo "kp: err: incorrect number of arguments"
		return 1
	fi

	ps aux | grep $1 > /dev/null
	PID=$(pidof $1)
	if [[ "$PID" != "" ]] ; then
		kill -9 $(pidof $1)
		if [[ "$?" == "0" ]] ; then
			echo "PID $PID ($1) killed"
		fi
	else
		echo "kp: err: no processes killed, could not find PID for process $1"
		return 1
	fi
}

# add to PATH variable
pathadd() {
	if [[ $# -eq 0 ]] ; then
		echo "pathadd: err: incorrect number of arguments"
		return 1
	fi

	NEW=${1%/}
	if [[ -d "$1" ]] && ! echo $PATH | grep -E -q "(^|:)$NEW($|:)" ; then
		if [ "$2" == "after" ] ; then
			export PATH="$PATH:$NEW"
		else
			export PATH="$NEW:$PATH"
		fi
	fi
}

# remove from PATH variable
pathrm() {
	export PATH=`echo $PATH | sed -e "s;\(^\|:\)${1%/}\(:\|\$\);\1\2;g" -e 's;^:\|:$;;g' -e 's;::;:;g'`
}

# remove duplicates from PATH variable (deduplicate)
pathdedup() {
	export PATH=`perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, $ENV{PATH}))'`
}

# get the default branch for a git repo
gitdefault() {
	git remote show ${1:-"origin"} | grep "HEAD branch" | cut -d ":" -f 2
}

# remove all subdirectories from a directory
rmd() {
	if [ $# -eq 0 ] ; then
		rm -rf -- */
	elif [ $# -eq 1 ] ; then
		rm -rf -- $1/*/
	else
		echo "rmd: err: incorrect number of arguments"
		return 1
	fi
}

# generate a random string of specified length, great for passwords
random() {
	strings /dev/urandom | grep -o '[[:alnum:]]' | head -n ${1:-30} | tr -d '\n'; echo
}

# make a shell script out of the last x commands
makes() {
	fc -rnl > /dev/null 2>&1
	if [[ $? -ne 0 ]] ; then 
		echo "makes: err: history is empty"
		return 1
	fi

	if [ $# -eq 0 ] ; then
		num=1
		name="script.sh"
	elif [ $# -eq 1 ] ; then
		num=$1
		name="script.sh"
	elif [ $# -eq 2 ] ; then
		num=$1
		name=$2
	else
		echo "makes: err: incorrect number of arguments"
		return 1
	fi

	rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
	fc -rnl | head -$num > $rando
	tac $rando > $name
	rm -rf $rando
}

# make a BASH function out of the last x commands
makef() {
	fc -rnl > /dev/null 2>&1
	if [[ $? -ne 0 ]] ; then 
		echo "makef: err: history is empty"
		return 1
	fi

	if [ ! ~/.bash_functions ] ; then
		source=~/.bashrc
	else
		source=~/.bash_functions
	fi

	if [ $# -eq 0 ] ; then
		num=1
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
		name="function_$rando"
	elif [ $# -eq 1 ] ; then
		num=$1
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
		name="function_$rando"
	elif [ $# -eq 2 ] ; then
		num=$1
		name=$2
		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 30 | tr -d '\n'; echo)"
	else
		echo "makef: err: incorrect number of arguments"
		return 1
	fi

	num="$(($num + 1))"

	printf "\n" >> $source
	printf "$name() {\n" >> $source
	fc -rnl | head -$num > $rando
	tac $rando > .tempfile

	index=0
	while IFS='' read -r CMD || [[ -n "$CMD" ]] ; do
		if [ $index -eq 0 ] ; then
			index+=1
			continue
		fi
		printf "$CMD\n" >> $source
	done < ".tempfile"

	printf "}\n" >> $source

	rm -rf .tempfile
	rm -rf $rando
	source ~/.bashrc
}

# remove a BASH Function by name
removef() {
	if [ $# -ne 1 ] ; then
		echo "removef: err: incorrect number of arguments"
	else
		if [ ~/.bash_functions ] ; then
			source=~/.bash_functions
		else
			source=~/.bashrc
		fi

		rando="$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n $num | tr -d '\n'; echo)"
		title="$1() {"
		edit=0
		found=0
		count=0
		while IFS='' read -r line || [[ -n "$line" ]] ; do
			if [ "$title" == "$line" ] && [ $edit -eq 0 ] ; then
				edit=1
				found=1
			elif [ "$line" == "}" ] && [ $edit -eq 1 ] ; then
				edit=0
				count="$(($count + 1))"
			else
				if [ $edit -eq 0 ] ; then
					printf "%s\n" "$line" >> $rando
				fi
			fi
		done < "$source"

		cat $rando > $source
		rm -rf $rando
		if [ $found -eq 0 ] ; then
			echo "$1 not found in $source"
		else
			if [ $count -eq 1 ] ; then
				echo "Removed $1 from $source"
				source ~/.bashrc
			else
				echo "Removed $1 $count times from $source"
				source ~/.bashrc
			fi
		fi
	fi
}

# list all BASH functions
lsf() {
	if [ ~/.bash_functions ] ; then
		source=~/.bash_functions
	else
		source=~/.bashrc
	fi

	while IFS='' read -r line || [[ -n $line ]] ; do
		let="$(echo $line | fold -w1)"
		chars="$(echo $let | tr -d '\040\011\012\015')"

		if [[ ( "${chars[*]: -1}" == "{" ) && ( "${chars: -2:1}" == ")" && "${chars: -3:1}" == "(" ) ]] ; then
			len=${#chars}
			len="$(($len - 1))"
			echo "${chars:0:$len}"
		fi
	done < "$source"
}

# function that does nothing (great for testing purposes)
dummy() {
	return 0
}

# search through command history
histg() {
	if [ $# -ne 1 ] ; then
		echo "histg: err: incorrect number of arguments"
		return 1
	fi

	history | grep "$1"
}

# intercept the `stderr` and `stdout` of a process
intercept() {
	if [[ $# -ne 1 ]] ; then
		echo "intercept: err: incorrect number of arguments"
		return 1
	fi

	strace -ff -e trace=write -e write=1,2 -p $1
}

# show my current public IP address
publicip() {
	echo `dig +short myip.opendns.com @resolver1.opendns.com`
}

# get location for your public IP address
getlocation() {
	myip="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	details="$(lynx -dump "$(publicip)".ip-adress.com | egrep 'City|State Code|Country Code')"
	frmt="IP: $myip\n"
	index=0
	while IFS= read -r line ; do
		if [ $index -eq 0 ] ; then
			city="$(echo $line | cut -d " " -f2-)"
			let index=index+1
		elif [ $index -eq 1 ] ; then
			country="$(echo $line | cut -d " " -f3-)"
			let index=index+1
		else
			state="$(echo $line | cut -d " " -f3-)"
			let index=index+1
		fi
	done <<< "$details"

	location="Location: $city, $state, $country"
	frmt+="$location"
	echo -e $frmt
}

# make it look like you're busy
busy() {
	cat /dev/urandom | hexdump -C | grep "ca fe"
}

# sort by size of current directory
sbs() {
	if [[ $# -ne 0 ]] ; then
		if [[ $# -eq 1 ]] ; then
			if [[ -d $1 ]] ; then
				cd $1
			else
				echo "sbs: err: $1 is not a valid directory"
				return 1
			fi
		fi
	fi

	du -hs * | sort -h
	
	if [[ $# -ne 0 ]] ; then
		cd -
	fi
}

# make directory prefixed with the date
mkdate() {
	local DIR="$(date +%F)-$1"
	mkdir $DIR
}

# make directory prefixed with the date and change into it
mkcddate() {
	local DIR="$(date +%F)-$1"
	mkdir $DIR
	cd $DIR
}

# sound the alarm
siren() {
	printf '\033[5m\033[91m%b\033[0m' '\'{127,105,105,40,127,117,117} && echo
}

# do you really need a description
rickroll() {
	STRING="$(printf '%b' '\'{116,145,166,145,162,040,147,157,156,156,141,040,147,151,166,145,040,171,157,165,040,165,160,056,056,056})"
	yes "$STRING"
}

# reverse input
rev() {
	if [[ $# -eq 0 ]] ; then
		__=""
		_stdin=""

		read -N1 -t1 __ && {
			(( $? <= 128 )) && {
				IFS= read -rd '' _stdin
				_stdin="$__$_stdin"
			}
		}

		VAL=$_stdin
		if [[ "$VAL" == "" ]] ; then
			echo "rev: err: no input found on stdin"
			return 1
		fi
	else
		if [[ $# -ne 1 ]] ; then
			echo "rev: err: incorrect number of arguments"
			return 1
		fi
		VAL=$1
	fi
	echo $VAL | sed $'s/./&\\\n/g' | sed -ne $'x;H;${x;s/\\n//g;p;}'
}

# list all cows
lscows() {
	COWS=`cowsay -l | tail -n +2 | tr ' ' '\n'`
	for COW in $COWS; do cowsay -f $COW $COW; done
}

# random animal speech
randimal() {
	if [[ $# -eq 0 ]] ; then
		fortune | cowsay -f `cowsay -l | tail -n +2 | tr ' ' '\n' | shuf -n 1` | lolcat
	else
		echo "$1" | cowsay -f `cowsay -l | tail -n +2 | tr ' ' '\n' | shuf -n 1` | lolcat
	fi
}

# list what kinds of files are in a directory
what() {
	find ${1:-"."} -type f | perl -ne 'print "." . $1 if m/\.([^.\/]+)$/'
}

# show percentage of each filetype in directory and its subdirectories
per() {
	stats="$(find ${1:-"."} -type f | sed 's/.*\.//' | sort | uniq -c)"

	total=0
	index=0
	for stat in $stats; do
		if (( $index % 2 == 0 )) ; then
			total="$(($total + $stat))"
		fi
		index="$(($index + 1))"
	done

	index=0
	num=0
	word=0
	out=""
	for stat in $stats; do
		if [[ $index -eq 0 ]] ; then
			num="$stat"
			word=$stat
		else
			word="$word $stat"
		fi
		index="$(($index + 1))"
		if (( $index % 2 == 0 )) ; then
			per="$(echo "scale=10; $num/$total" | bc)"
			per="$(echo "scale=10; $per * 100" | bc)"
			per="$(echo "scale=2; $per/1" | bc)"
			out="$out\n$word ($per%)"
			index=0
			word=""
		fi
	done

	echo -e $out | column -t
}

# list all files of specific type
show() {
	if [[ $# -eq 0 ]] ; then
		echo "show: err: incorrect number of arguments"
		return 1
	elif [[ $# -eq 1 ]] ; then
		find . -type f -name "*.$1"
	else
		while [[ $# -ne 0 ]] ; do
			printf "\033[94m.$1 files:\033[0m\n"
			find . -type f -name "*.$1"
			shift
		done
	fi
}

# get disk usage in a nicer format
dup() {
	if [[ $# -ne 0 ]] ; then
		if [[ -d "$1" ]] ; then
			cd "$1"
		else
			echo "dup: err: $1 is not a valid directory"
			return 1
		fi
	fi

	du -sh --apparent-size *
	DU="$(du -sh --apparent-size .)"
	read -ra ARR <<<"$DU"
	echo " TOTAL: ${ARR[0]}"

	if [[ $# -ne 0 ]] ; then
		cd - > /dev/null
	fi
}

# get disk usage for specific filetype
duf() {
	if [ $# -eq 0 ] ; then
		echo "duf: err: incorrect number of arguments"
		return 1
	fi

	for arg in "$@"; do
		size="$(find . -name "*.$1" -print0 | xargs -0 du --apparent-size -ch | tail -n1)"
		read -ra ARR <<<"$SIZE"
		echo "$1: ${ARR[0] - $1}"
		shift
	done
}

# clear a file
clear() {
	if [[ $# -eq 0 ]] ; then
		command clear
	else
		for file in "$@"; do
			if [[ -f "$file" ]] ; then
				> "$file"
			fi
		done
	fi
}

# select files at random from a directory
get() {
	ls -p | grep -v / | sort -R | tail -${1:-1} | while read FILE ; do
		echo "$FILE"
	done
}

# remove files at random
del() {
	ls -p | grep -v / | sort -R | tail -${1:-1} | while read FILE ; do
		rm -rf "$FILE"
	done
}

# grep line by line
lbl() {
	if [[ $# -ne 2 ]] ; then
		echo "lbl: err: incorrect number of arguments"
		return 1
	fi

	while IFS= read -r RESULT ; do
		echo $RESULT
		read </dev/tty
	done < <(grep "$1" $2)
}

# pause execution
pause() {
	read -n 0 -rsp $'Press any key to continue...\n'
}

# reset Macbook Pro touch bar
resetbar() {
	pkill "Touch Bar agent"
	killall "ControlStrip"
}

# make a new git repo
mkgit() {
	if [[ $# -ne 1 ]] ; then
		echo "mkgit: err: incorrect number of arguments"
		return 1
	fi

	mkdir "$1"
	cd "$1"
	git init
}

# copy current directory to clipboard
cppwd() {
	DIR=`pwd`
	pbcopy <<< "$DIR"
}

# copy previous command to Mac clipboard (CoPy Last Command)
cplc() {
	pbcopy <<< "!!"
}

# copy output from previous command to Mac clipboard (CoPy Last command Output)
cplo() {
	pbcopy <<< "`!!`"
}

# git clone and cd into new directory
clonecd() {
	git clone "$1" && cd "$(basename "$1")"
}

# create new remote repository on GitHub and push the current commit to it
rcreate() {
	if [[ $# -eq 1 ]] ; then
		REPO="$1"
	else
		REPO="${PWD##*/}"
	fi

	GITHUBUSER=`git config github.user`

	curl -u ${USER:-${GITHUBUSER}} https://api.github.com/user/repos -d "{\"name\": \"${REPONAME:-${REPO}}\", \"private\": false, \"has_issues\": true, \"has_downloads\": true, \"has_wiki\": false}" > /dev/null
	git remote add origin git@github.com:${USER:-${GITHUBUSER}}/${REPONAME:-${REPO}}.git
	git push --set-upstream origin master
}

# execute a file and open it in Sublime
eao() {
	if [[ $# -eq 0 ]] ; then
		echo "eao: err: incorrect number of arguments"
		return 1
	fi

	FILE="$1"
	EXT="${FILE##*.}"
	subl "$1"
	case "$EXT" in
		"sh")	./"$@"			;;
		"py")	python3 "$@"	;;
		"rb")	ruby "$@"		;;
		"java")	java "$@"		;;
		*)		echo "Can't execute $1"
	esac
}

# update Konphig settings for system
update() {
	OS=`ostype`
	if [[ "$OS" == "Mac" ]] ; then
		CMD="MD5 -q"
	else
		CMD="md5sum"
	fi

	VAL=0

	if ! [[ "$($CMD ~/Konphig/.bash_aliases)" == "$($CMD ~/.bash_aliases)" ]] ; then
		echo "Updating .bash_aliases"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_aliases ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_variables)" == "$($CMD ~/.bash_variables)" ]] ; then
		echo "Updating .bash_variables"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_variables ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_functions)" == "$($CMD ~/.bash_functions)" ]] ; then
		echo "Updating .bash_functions"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_functions ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bash_profile)" == "$($CMD ~/.bash_profile)" ]] ; then
		echo "Updating .bash_profile"
		VAL=1
		yes | cp -rf ~/Konphig/.bash_profile ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.bashrc)" == "$($CMD ~/.bashrc)" ]] ; then
		echo "Updating .bashrc"
		VAL=1
		yes | cp -rf ~/Konphig/.bashrc ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.git-prompt.sh)" == "$($CMD ~/.git-prompt.sh)" ]] ; then
		echo "Updating .git-prompt.sh"
		VAL=1
		yes | cp -rf ~/Konphig/.git-prompt.sh ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.gitconfig)" == "$($CMD ~/.gitconfig)" ]] ; then
		echo "Updating .gitconfig"
		VAL=1
		yes | cp -rf ~/Konphig/.gitconfig ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.profile)" == "$($CMD ~/.profile)" ]] ; then
		echo "Updating .profile"
		VAL=1
		yes | cp -rf ~/Konphig/.profile ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.tmux.conf)" == "$($CMD ~/.tmux.conf)" ]] ; then
		echo "Updating .tmux.conf"
		VAL=1
		yes | cp -rf ~/Konphig/.tmux.conf ~ >/dev/null 2>&1
	fi
	if ! [[ "$($CMD ~/Konphig/.vimrc)" == "$($CMD ~/.vimrc)" ]] ; then
		echo "Updating .vimrc"
		VAL=1
		yes | cp -rf ~/Konphig/.vimrc ~ >/dev/null 2>&1
	fi

	if [[ $VAL -eq 0 ]] ; then
		echo "Nothing to update"
	else
		source ~/.bashrc
	fi
}

# gives the current user execution privileges for a file
gimme() {
	if [[ $# -ne 1 ]] ; then
		echo "gimme: err: incorrect number of arguments"
		return 1
	fi
	chmod +x "$1"
}

# open a file in Google Chrome from the command line
chrome() {
	if [[ $# -eq 0 ]] ; then
		echo "chrome: err: incorrect number of arguments"
		return 1
	fi
	for ARG in "$@" ; do
		open -a "Google Chrome" "$ARG"
	done
}

# open a file in Brave browser from the command line
brave() {
	if [[ $# -eq 0 ]] ; then
		echo "brave: err: incorrect number of arguments"
		return 1
	fi
	for ARG in "$@" ; do
		open -a "Brave Browser" "$ARG"
	done
}

# follow a directory tree down to its childmost directory
dive() {
    if [[ $# -ne 1 ]] ; then
        echo "dive: err: incorrect number of arguments"
        return 1
    fi  
    if [[ ! -d "$1" ]] ; then
        echo "dive: err: no such directory $1"
        return 1
    fi  
    TARGET="`readlink -m $1`"
    END=0
    while [[ $END -eq 0 ]] ; do
        DIRS=()
        for THING in $TARGET/* ; do if [[ -d $THING ]] ; then DIRS+=( "`basename $THING`" ) ; fi ; done
        if [[ ${#DIRS[@]} -eq 1 ]] ; then TARGET="$TARGET/${DIRS[0]}" ; END=0 ; else END=1 ; fi
    done
    cd "$TARGET"
    pwd 
}

# get help for BASH commands
aid() {
    if [[ $# -ne 1 ]] ; then
        echo "aid: err: incorrect number of arguments"
        return 1
    fi
    curl cheat.sh/$1
}

# pretty print JSON files
json() {
    if [[ $# -eq 0 ]] ; then
        echo "json: err: incorrect number of arguments"
        return 1
    fi
    for ARG in $@ ; do
        cat $ARG | jq .
    done
}
